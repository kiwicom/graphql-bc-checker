#!/usr/bin/env node

// @flow

import os from 'os';
import path from 'path';
import { findBreakingChanges, buildSchema, printSchema } from 'graphql';
import program from 'commander';
import SignedSource from '@kiwicom/signed-source';
import fs from 'fs';

import { buildBreakingChangesBlock } from './BCLogger';
import { printChanges, note, success, warning, error } from './Printer';

const required = (option: string) => {
  throw new Error(
    `You have to specify ${option} in order to run this command.`,
  );
};

program
  .option('--allow-breaking-changes')
  .option('--snapshot <path>', 'Location of the GraphQL Schema snapshot.')
  .option(
    '--schema <path>',
    'Location of the JS file with GraphQLSchema export.',
  )
  .parse(process.argv);

const flagAllowBreakingChanges = program.allowBreakingChanges ?? false;
const snapshotLocation = program.snapshot ?? required('--snapshot');
const schemaLocation = program.schema ?? required('--schema');

const terminate = (cb?: () => void = () => {}) => {
  cb();
  process.exit(1);
};

const createSnapshot = (breakingChangesBlock, newSchema) => {
  return SignedSource.signFile(
    `# ${SignedSource.getSigningToken()}` +
      os.EOL +
      os.EOL +
      breakingChangesBlock +
      os.EOL +
      os.EOL +
      printSchema(newSchema),
  );
};

fs.access(snapshotLocation, fs.constants.F_OK, err => {
  // $FlowAllowDynamicImport
  const newSchema = require(path.join(process.cwd(), schemaLocation)).default;

  if (err) {
    // first run, snapshot doesn't exist yet (we have to just snapshot the schema)

    const breakingChangesBlock = buildBreakingChangesBlock('');
    const newSnapshot = createSnapshot(breakingChangesBlock, newSchema);

    fs.writeFileSync(snapshotLocation, newSnapshot);

    success(`New GraphQL snapshot saved to: ${snapshotLocation}`);
  } else {
    // snapshot is readable

    const oldSnapshot = fs.readFileSync(snapshotLocation).toString();
    const oldSchema = buildSchema(oldSnapshot);

    const changes = findBreakingChanges(oldSchema, newSchema);
    if (changes.length > 0) {
      printChanges(changes);
      if (flagAllowBreakingChanges === false) {
        terminate();
      }
    }

    const breakingChangesBlock = buildBreakingChangesBlock(
      oldSnapshot,
      changes,
    );
    const newSnapshot = createSnapshot(breakingChangesBlock, newSchema);

    if (!SignedSource.verifySignature(oldSnapshot)) {
      terminate(
        error(
          'Manual changes of GraphQL snapshot detected. Please do not update GraphQL snapshot manually. This file is being autogenerated.',
        ),
      );
    }

    if (newSnapshot !== oldSnapshot) {
      warning('GraphQL schema snapshot IS OUTDATED! (updating automatically)');
      fs.writeFileSync(snapshotLocation, newSnapshot);

      // this is also considered failure so CI will fail (must be committed manually)
      terminate(
        note(
          'Snapshot of the GraphQL schema successfully created! Now please commit it...',
        ),
      );
    } else {
      success(
        'Congratulations! NO BREAKING CHANGES or OUTDATED SCHEMA. Good job!',
      );
    }
  }
});
